(defmethod zero-const-p ((expr expression))
  nil)

(defmethod zero-const-p ((expr const))
  (zerop (slot-value expr 'value))

(defmethod simplify ((expr +-expr))
  (let* ((result (call-next-method))
         (expr-1 (slot-value result 'expr-1))
         (expr-2 (slot-value result 'expr-2)))
    (cond ((zero-const-p expr-1) expr-2)
          ((zero-const-p expr-2) expr-1)
          (t result))))

;definujte metody simplify i pro tridy --expr, *-expr, /-expr tak, aby umely zjednodusovat:
;- soucin nuly a libovolneho vyrazu (zleva i zprava)
;- soucin jednicky a libovolneho vyrazu (zleva i zprava)
;- rozdil libovolneho vyrazu a nuly
;- podil libovolneho vyrazu a jednicky

;;--------------------;;
;8.14::  binary expression, doplnit metodu tak, aby binarni vyraz,ktery obsahuje dve konstanty zjednodusila na konstantu
;napr: (representation (simplify (parse '(+ 1 2)))) => 3


;;-------------------;;
;8.17:: zavest derivaci jako binarni vyraz
; + chyba, pokud neni druhy vyraz pro derivaci promenna

(defclass deriv (binary-expression)
  ())

(defmethod set-var ((self deriv) expr)
  (unless (typep expr 'var)
    (error "Druha hodnota musi byt promenna!"))
  (setf (slot-value self 'set-var) expr)
  self)

;-----
(defnethod bin-expr-symbol ((self deriv))
           'sym)
(defvar *bin-expr-class* 'binary-expression)
(defvar *deriv-class 'deriv)

(defmethod simplify ((self deriv))
  (simplify
   (cond ((typep (expr-1 self) *const-expr-class* (make-instance *const-expr-class*))
          ((typep (expr-1 self) *var-expr-class*) (parse (if (eql (name self) (name var)) 1 0)))
          ((typep (expr-1 e) *bin-expr-class*)
           (let ((expr-1 (expr-1 (expr-1 self)))
                 (expr-2 (expr-2 (expr-2 self)))
                 (var (expr-2 self)))
             (cond ((or (typep (expr-1 self) *+-expr-class*) (typep (expr-1 self) *--expr-class-))
                    (parse `(,(bin-expr-symbol (expr-1 self)) ,(deriv expr-1 var) ,(deriv expr-2 var))))
                  ((typep (expr-1 self) **-expr-class*)
                   (parse `(+ (* ,(deriv.expr-1 var) ,expr-2)
                              (* ,expr-1 ,(deriv expr-2 var)))))
                  ((typep (expr-1 self) */-expr-1-class*)
                   (parse `(/ (- (* ,(deriv expr-1 var) ,expr-2)
                                 (* ,expr-1 ,(deriv expr-2 var)))
                              (* ,expr-2 ,expr-2))))
                  (t self))))))))


(defun make-binary-expr (name expr-1 expr-2)
  (let ((result (make-instance
                 (cond
                  ((eql name '+) *+-expr-class*)
                  ((eql name '-) *--expr-class*)
                  ((eql name '*) **-expr-class*)
                  ((eql name '/) */-expr-class*)
                  ((eql name 'sym) *deriv-class*)))))
    (set-expr-1 result (parse expr-1))
    (set-expr-2 result (parse expr-2))
    result))


                   
          
          
         